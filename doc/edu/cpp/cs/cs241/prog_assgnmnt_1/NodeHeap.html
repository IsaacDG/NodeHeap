<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_20) on Fri Jan 29 14:45:41 PST 2016 -->
<title>NodeHeap</title>
<meta name="date" content="2016-01-29">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="NodeHeap";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/NodeHeap.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/RestaurantProgram.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" target="_top">Frames</a></li>
<li><a href="NodeHeap.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">edu.cpp.cs.cs241.prog_assgnmnt_1</div>
<h2 title="Class NodeHeap" class="title">Class NodeHeap&lt;V extends java.lang.Comparable&lt;V&gt;&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>edu.cpp.cs.cs241.prog_assgnmnt_1.NodeHeap&lt;V&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html" title="interface in edu.cpp.cs.cs241.prog_assgnmnt_1">Heap</a>&lt;V&gt;</dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">NodeHeap&lt;V extends java.lang.Comparable&lt;V&gt;&gt;</span>
extends java.lang.Object
implements <a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html" title="interface in edu.cpp.cs.cs241.prog_assgnmnt_1">Heap</a>&lt;V&gt;</pre>
<div class="block">This class is an implementation of the heap data structure using Nodes. The Nodes are linked like a linked
 list, but have 3 links. One for the parent, and 2 for the children.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Isa</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>(package private) <a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#lastElement">lastElement</a></span></code>
<div class="block">The last element that was added to the heap.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#numElements">numElements</a></span></code>
<div class="block">The number of elements that are in the heap.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>(package private) <a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#root">root</a></span></code>
<div class="block">Keeps track of the first node in the heap.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#NodeHeap--">NodeHeap</a></span>()</code>
<div class="block">Default constuctor that sets the root to null and the number of elements to 0.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#add-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-">add</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;origin,
   <a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;addNode)</code>
<div class="block">This method is used to find the correct path to the deepest, left-most node.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#add-V-">add</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&nbsp;value)</code>
<div class="block">This method wraps around the {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#add-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-"><code>add(Node, Node)</code></a> method.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#arraySiftDown-V:A-int-int-">arraySiftDown</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array,
             int&nbsp;current,
             int&nbsp;length)</code>
<div class="block">NOTE: The length parameter is not necessarily the length of the entire array.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#findPlace-int-">findPlace</a></span>(int&nbsp;place)</code>
<div class="block">This method is used to find a specific node in the heap.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#fromArray-V:A-">fromArray</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array)</code>
<div class="block">This method simply takes in any array of elements and adds each element to the heap.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#getRoot--">getRoot</a></span>()</code>
<div class="block">Returns <a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#root"><code>root</code></a></div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#getSortedContents-V:A-">getSortedContents</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array)</code>
<div class="block">This method sends the heap to its array form, which is unsorted.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#heapify-V:A-">heapify</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array)</code>
<div class="block">This method is used to heapify an array.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#heapSort-V:A-">heapSort</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;arrayHeap)</code>
<div class="block">This method sorts a heapified array.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#printInorder-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-">printInorder</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;root)</code>&nbsp;</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#remove--">remove</a></span>()</code>
<div class="block">This method is used to remove an element from the heap.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#siftDown-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-">siftDown</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;current)</code>
<div class="block">This is a recursive method that sifts a Node down the heap structure to maintain the rules of the heap.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#siftUp-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-">siftUp</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;current)</code>
<div class="block">This method starts by identifying the parent node of the node we want to sift up.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#size--">size</a></span>()</code>
<div class="block">Returns {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#numElements"><code>numElements</code></a>.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#swap-V:A-int-int-">swap</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array,
    int&nbsp;from,
    int&nbsp;to)</code>
<div class="block">This method is a standard swapping method for swapping elements in an array.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#toArray-V:A-">toArray</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array)</code>
<div class="block">This method simply traverses the NodeHeap.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#traverse-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-V:A-">traverse</a></span>(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;cursor,
        <a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array)</code>
<div class="block">This method traverses the entire NodeHeap, no matter what size it is.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="root">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>root</h4>
<pre><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a> extends java.lang.Comparable&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&gt; root</pre>
<div class="block">Keeps track of the first node in the heap. This is the node that is at the very top
 of the heap, and is the largest element in it.</div>
</li>
</ul>
<a name="lastElement">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lastElement</h4>
<pre><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a> extends java.lang.Comparable&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&gt; lastElement</pre>
<div class="block">The last element that was added to the heap.</div>
</li>
</ul>
<a name="numElements">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>numElements</h4>
<pre>private&nbsp;int numElements</pre>
<div class="block">The number of elements that are in the heap.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="NodeHeap--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>NodeHeap</h4>
<pre>public&nbsp;NodeHeap()</pre>
<div class="block">Default constuctor that sets the root to null and the number of elements to 0.</div>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="add-java.lang.Comparable-">
<!--   -->
</a><a name="add-V-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public&nbsp;void&nbsp;add(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&nbsp;value)</pre>
<div class="block">This method wraps around the {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#add-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-"><code>add(Node, Node)</code></a> method. A value is passed in
 that we want to add. First it checks the base case where the heap is empty. If it is empty,
 The root is set to a new Node with the value we want to add. Otherwise, we use the {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#add-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-"><code>add(Node, Node)</code></a>
 method to add a new node at the deepest, left most node and sift it up.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html#add-V-">add</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html" title="interface in edu.cpp.cs.cs241.prog_assgnmnt_1">Heap</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a> extends java.lang.Comparable&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&gt;</code></dd>
</dl>
</li>
</ul>
<a name="siftUp-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>siftUp</h4>
<pre>public&nbsp;void&nbsp;siftUp(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;current)</pre>
<div class="block">This method starts by identifying the parent node of the node we want to sift up.
 If the parent is not a null node, the data of the parent node and the current node
 are compared. If the parent node is smaller, then the nodes data is swapped.
 Next, the parent is sifted up to continue the sifting up process recursively.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>current</code> - The current node that needs to be compared and checked for possible sifting.</dd>
</dl>
</li>
</ul>
<a name="add-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public&nbsp;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;add(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;origin,
                   <a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;addNode)</pre>
<div class="block">This method is used to find the correct path to the deepest, left-most node. First, the location(or index)
 of the parent node is calculated by getting the index of the node to add and using the basic parent finding
 equation on that value. If the parent index is equal to the index of the node that was used to begin the path
 (or origin node), then the path to add is chosen by simply figuring out whether to add the node to the origin node's
 left or right child.
 
 If the origin index is not the parent of the node we want to add, a loop is used to find the parent of
 the parent of the node we want to add. The loop executes until the ancestor node's index finds the origin node's
 index. This loop essentially traverses the heap upwards until it finds the origin node.
 
 After the origin node is found, a conditional statement is used to determine which path the next
 instance of the method should take. It does this by using the ancestor node's index to figure out
 if it should go left or right using the modulus operation. Once the path is found, this method is called
 again using a new origin node, which is the path we just found, and the same node we want to add.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>origin</code> - The node that the path of the method originates from. It starts from the top to find which path it should
 take downwards.</dd>
<dd><code>addNode</code> - The node we want to add, we need the information like its index to perform many of the operations in this
 method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The node we added.</dd>
</dl>
</li>
</ul>
<a name="findPlace-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPlace</h4>
<pre>public&nbsp;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;findPlace(int&nbsp;place)</pre>
<div class="block">This method is used to find a specific node in the heap. A <code>int</code> value is passed
 in, and a Node is set to the root. Using Integer, the binary value of the int passed in is 
 found and stored in a char array called <code>binary</code>.
 A for loop is then used to process every bit(except the first) of the char array. If the bit value is '0',
 then the cursor node traverses to its left child. If the bit value is '1', then the cursor node
 traverses to its right child. Once the traversing is done, the Node in the place we wanted to find
 is returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>place</code> - The place in the heap that we want the node for.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The node in the place we wanted to find.</dd>
</dl>
</li>
</ul>
<a name="printInorder-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printInorder</h4>
<pre>public&nbsp;void&nbsp;printInorder(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;root)</pre>
</li>
</ul>
<a name="toArray-java.lang.Comparable:A-">
<!--   -->
</a><a name="toArray-V:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toArray</h4>
<pre>public&nbsp;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;toArray(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array)</pre>
<div class="block">This method simply traverses the NodeHeap. It visits every node using the {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#traverse-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-V:A-"><code>traverse(Node, Comparable[])</code></a>
 method and adds each element to the array. After the method is done, it returns the array.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html#toArray-V:A-">toArray</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html" title="interface in edu.cpp.cs.cs241.prog_assgnmnt_1">Heap</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a> extends java.lang.Comparable&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&gt;</code></dd>
</dl>
</li>
</ul>
<a name="traverse-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-java.lang.Comparable:A-">
<!--   -->
</a><a name="traverse-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-V:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>traverse</h4>
<pre>public&nbsp;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;traverse(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;cursor,
                    <a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array)</pre>
<div class="block">This method traverses the entire NodeHeap, no matter what size it is. A Node is passed in as an argument and is
 treated as a cursor. If the cursor is not null, then the element of the cursor node is added to the array
 by getting the <code>getNum()</code> method of the Node class. This returns the element index of the Node, which
 is also the index of the place in the array that the element belongs to. The element in the array is set to
 the data of the cursor node. Then, {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#traverse-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-V:A-"><code>traverse(Node, Comparable[])</code></a> is called recursively on the
 cursors children to repeat the process until the entire tree has been traversed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cursor</code> - The node we want to add to the array, and the node we want the children for.</dd>
<dd><code>array</code> - The array we want to add elements to.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The complete array representation of the heap.</dd>
</dl>
</li>
</ul>
<a name="remove--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>remove</h4>
<pre>public&nbsp;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&nbsp;remove()</pre>
<div class="block">This method is used to remove an element from the heap. This will always remove the data at the root of the
 heap. First, the base case is checked where the root is the only element in the heap. If this is the case,
 the root is simply set to null. Otherwise, {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#lastElement"><code>lastElement</code></a> is found by using the {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#findPlace-int-"><code>findPlace(int)</code></a>
 method. The root data is then set to {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#lastElement"><code>lastElement</code></a>'s data and the parent of the last element is found.
 If the parent of the last element is full, then that means we need to remove the right child. If it is not full,
 then we remove the left child. Lastly, the recursive method {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#siftDown-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-"><code>siftDown(Node)</code></a> is called on the root
 to maintain the heap structure.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html#remove--">remove</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html" title="interface in edu.cpp.cs.cs241.prog_assgnmnt_1">Heap</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a> extends java.lang.Comparable&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&gt;</code></dd>
</dl>
</li>
</ul>
<a name="siftDown-edu.cpp.cs.cs241.prog_assgnmnt_1.Node-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>siftDown</h4>
<pre>public&nbsp;void&nbsp;siftDown(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1">Node</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&nbsp;current)</pre>
<div class="block">This is a recursive method that sifts a Node down the heap structure to maintain the rules of the heap.
 First, the base case is checked where the node being sifted is a leaf. If it is a leaf, then the method
 simply terminates. Otherwise, The data of the child nodes is found. 
 
 All swaps are only made if the data in a child is greater than the data in the current node.
 
 If the node only has one child(the left child),
 then the current nodes data is only compared to the left child's data. Otherwise, the method checks if 
 either of the children are greater than the parent nodes data. If one of them is, the data of the children
 is compared to figure out which child the parent's data should be swapped to. Once the data is swapped,
 the method is called recursively on the sifted down node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>current</code> - The current node that needs to be checked for sifting.</dd>
</dl>
</li>
</ul>
<a name="fromArray-java.lang.Comparable:A-">
<!--   -->
</a><a name="fromArray-V:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromArray</h4>
<pre>public&nbsp;void&nbsp;fromArray(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array)</pre>
<div class="block">This method simply takes in any array of elements and adds each element to the heap.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html#fromArray-V:A-">fromArray</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html" title="interface in edu.cpp.cs.cs241.prog_assgnmnt_1">Heap</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a> extends java.lang.Comparable&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&gt;</code></dd>
</dl>
</li>
</ul>
<a name="getSortedContents-java.lang.Comparable:A-">
<!--   -->
</a><a name="getSortedContents-V:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSortedContents</h4>
<pre>public&nbsp;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;getSortedContents(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array)</pre>
<div class="block">This method sends the heap to its array form, which is unsorted. Once the array form is computed, the method returns
 {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#heapSort-V:A-"><code>heapSort(Comparable[])</code></a> called on that array.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html#getSortedContents-V:A-">getSortedContents</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Heap.html" title="interface in edu.cpp.cs.cs241.prog_assgnmnt_1">Heap</a>&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a> extends java.lang.Comparable&lt;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&gt;&gt;</code></dd>
</dl>
</li>
</ul>
<a name="heapify-java.lang.Comparable:A-">
<!--   -->
</a><a name="heapify-V:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>heapify</h4>
<pre>public&nbsp;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;heapify(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array)</pre>
<div class="block">This method is used to heapify an array. This method is not used throughout the code, but I wanted to try
 to implement it any way. First, the last non-leaf element is found. Then, the base case is checked. If
 the heap only has one element, then nothing happens.
 Otherwise, a loop is executed that calls the {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#arraySiftDown-V:A-int-int-"><code>arraySiftDown(Comparable[], int, int)</code></a> method on
 the last non leaf element. The loop then goes through each element before the last non leaf element until
 it is at the root. Because of the properties of sift down, this heapifies the array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>array</code> - The array we want to heapify.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The heapified array.</dd>
</dl>
</li>
</ul>
<a name="heapSort-java.lang.Comparable:A-">
<!--   -->
</a><a name="heapSort-V:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>heapSort</h4>
<pre>public&nbsp;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;heapSort(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;arrayHeap)</pre>
<div class="block">This method sorts a heapified array. In order to do this, a variable called <code>unsorted</code> is kept track of.
 At first, unsorted is the size of the array passed in, because the entire array is unsorted. A while-loop
 is then executed until <code>unsorted</code> is equal to 1. In the loop, the {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#swap-V:A-int-int-"><code>swap(Comparable[], int, int)</code></a>
 method is called, swapping the first element in the array with the last element in the UNSORTED array. This sorts
 the array because the first element of the heap is always the greatest element in the heap. After the swap, the
 {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#arraySiftDown-V:A-int-int-"><code>arraySiftDown(Comparable[], int, int)</code></a> method is called to sift down the new root element to reheapify
 the array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arrayHeap</code> - The heap in array form.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sorted array.</dd>
</dl>
</li>
</ul>
<a name="arraySiftDown-java.lang.Comparable:A-int-int-">
<!--   -->
</a><a name="arraySiftDown-V:A-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>arraySiftDown</h4>
<pre>public&nbsp;void&nbsp;arraySiftDown(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array,
                          int&nbsp;current,
                          int&nbsp;length)</pre>
<div class="block">NOTE: The length parameter is not necessarily the length of the entire array. This param is
 used to stop sifting at a certain index of the array for {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#heapSort-V:A-"><code>heapSort(Comparable[])</code></a>
 purposes.
 
 This method sifts down an element in an array heap. First, the left and right children are found
 are found for the current index that we want to sift down. If the left and right indices are not
 greater than or equal to the length of the array, this means that element is not a leaf and we can continue
 the method, otherwise the method simply terminates.
 
 All swaps are made only if the data in the parent index is less than the data in the child index.
 The {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#swap-V:A-int-int-"><code>swap(Comparable[], int, int)</code></a> method is used for any swap that occurs.
 
 Otherwise, the method checks if the right index is equal to the length of the array, which means that
 the right index does not exist and we will only have to compare the current data to the left index's data.
 Otherwise, we compare the current index data with both of its children. If one of them is greater than
 the current data, then we compare the child indices to determine which child to swap with. Lastly, this method
 is called recursively on the child index that was swapped with to continue the sifting process.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>array</code> - The array that we want to work with</dd>
<dd><code>current</code> - This is the current index we want to sift down.</dd>
<dd><code>length</code> - This is the int value of the index where we want to stop the sifting process. Not necessarily the
 length of the entire array.</dd>
</dl>
</li>
</ul>
<a name="swap-java.lang.Comparable:A-int-int-">
<!--   -->
</a><a name="swap-V:A-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>swap</h4>
<pre>public&nbsp;void&nbsp;swap(<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>[]&nbsp;array,
                 int&nbsp;from,
                 int&nbsp;to)</pre>
<div class="block">This method is a standard swapping method for swapping elements in an array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>array</code> - The array we want to swap elements in.</dd>
<dd><code>from</code> - The index we are swapping from</dd>
<dd><code>to</code> - The index we are swapping to</dd>
</dl>
</li>
</ul>
<a name="size--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>size</h4>
<pre>public&nbsp;int&nbsp;size()</pre>
<div class="block">Returns {<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#numElements"><code>numElements</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>{<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#numElements"><code>numElements</code></a></dd>
</dl>
</li>
</ul>
<a name="getRoot--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getRoot</h4>
<pre>public&nbsp;<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" title="type parameter in NodeHeap">V</a>&nbsp;getRoot()</pre>
<div class="block">Returns <a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#root"><code>root</code></a></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>{<a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html#root"><code>root</code></a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/NodeHeap.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/Node.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../edu/cpp/cs/cs241/prog_assgnmnt_1/RestaurantProgram.html" title="class in edu.cpp.cs.cs241.prog_assgnmnt_1"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?edu/cpp/cs/cs241/prog_assgnmnt_1/NodeHeap.html" target="_top">Frames</a></li>
<li><a href="NodeHeap.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
